### 자바 컴파일러

- 컴파일된 코드는 플랫폼 독립적
  
  - 어떤 플랫폼, 하드웨어, 운영체제든 상관X
  
  - **JVM** 때문
    
    - 스택 기반의 가상머신
      
      - 레지스터 기반X
      
      - push, pop해서 연산하므로 느려요
    
    - 심볼릭 레퍼런스
      
      - class 파일이 jvm에 올라가면 그이름에 맞ㅈ는 객체의 주소를 찾아서 연결
      
      - 실제 메모리 주소가 아니라 이름만 가짐?
    
    - 가비지 컬렉션
      
      - 클래스 인스턴스는 자동으로 파과ㅣ
    
    - 기본 자료형을 명확히 정의, 플랫폼 독립성 보장
      
      - C/C++은 플랫폼에 따라 int형 크기 변함

### 순서

<img src="https://camo.githubusercontent.com/af3d43865302485f944cbc6a7a7c3fcb27d3227320e5bf0b2cd8013d76507c07/687474703a2f2f7463707363686f6f6c2e636f6d2f6c656374757265732f696d675f6a6176615f70726f6772616d6d696e672e706e67" title="" alt="" width="390"><img src="https://camo.githubusercontent.com/9ada78092a3d1fd3e81574ad2b48baf0db97baced4d4a3e0eca1b0d014152ae4/68747470733a2f2f74312e6461756d63646e2e6e65742f6366696c652f746973746f72792f393931443036344235414539393944353132" title="" alt="" width="365">

1. 자바 소스코드 작성

2. 자바 컴파일러로 컴파일
   
   - 자바 바이트 코드 (.class) 나옴
     
     -  JVM은 사용자 언어인 자바와 기계어 사이의 중간 언어인 자바 바이트코드를 사용한다. 이 자바 바이트코드가 자바 코드를 배포하는 가장 작은 단위이다.
   
   - JVM이해가능
   
   - 각 명령어와 1바이트의 추가 피연산자로 구성

3. JVM클래스 로더에 전달

4. 클래스 로더는 동적로딩(Dynamic Loading)을 통해 필요한 클래스들을 로딩 및 링크하여 런타임 데이터 영역(Runtime Data area),  JVM의 메모리에 올립니다.

<img src="https://t1.daumcdn.net/cfile/tistory/99B467465B73D15111" title="" alt="" width="250">

pc레지스터, jvm 스택, 네이티브 메소드 스택은 스레드마다 생성

- 네이티브 메소드 스택: 자바 이외의 네이티브 코드를 위한 스택 (c 라이브러리?)

- PC Register Area: 쓰레드마다 하나씩 생성. JVM 명령의 주소값이 저장되는 공간

heap과 메소드 영역은 공유

- heap -> garbage collection 대상

- 메소드 영역: 클래스와 메소드, 멤버(클래스, 인스턴스)변수와 상수(final) 정보 등이 저장되는 공간(garbage collection 선택 대상)

- 클래스 로더 세부 동작
  1. 로드 : 클래스 파일을 가져와서 JVM의 메모리에 로드합니다.
  2. 검증 : 자바 언어 명세(Java Language Specification) 및 JVM 명세에 명시된 대로 구성되어 있는지 검사합니다.
  3. 준비 : 클래스가 필요로 하는 메모리를 할당합니다. (필드, 메서드, 인터페이스 등등)
  4. 분석 : 클래스의 상수 풀 내 모든 심볼릭 레퍼런스를 다이렉트 레퍼런스로 변경합니다.
  5. 초기화 : 클래스 변수들을 적절한 값으로 초기화합니다. (static 필드)

<img src="https://t1.daumcdn.net/cfile/tistory/9949E83D5B73D7EA25" title="" alt="자바 컴파일러(JAVA Compiler) / JIT 컴파일러(JIT Compiler)" width="465">

5.실행엔진(Execution Engine)은 JVM 메모리에 올라온 바이트 코드들을 명령어 단위로 하나씩 가져와서 실행

1. 인터프리터 : 바이트 코드 명령어를 하나씩 읽어서 해석하고 실행합니다. 하나하나의 실행은 빠르나, 전체적인 실행 속도가 느리다

2. JIT 컴파일러(Just-In-Time Compiler) : 인터프리터의 단점을 보완하기 위해 도입된 방식으로 바이트 코드 전체를 컴파일하여 바이너리 코드로 변경하고 이후에는 해당 메서드를 더이상 인터프리팅 하지 않고, 바이너리 코드로 직접 실행하는 방식
   
   바이트 코드 전체가 컴파일된 바이너리 코드를 실행하는 것이기 때문에 인터프리팅 방식보다 빠릅니다.

**자바 8부터 도입된 javascript runtime engine인 nashhorn을 사용하여 java에서 javascript를 사용할 수 있다.**?
