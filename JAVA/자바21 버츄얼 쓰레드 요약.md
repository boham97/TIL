# 자바 21 버츄얼 쓰레드 공식 영상

[Java 21 new feature: Virtual Threads #RoadTo21 - YouTube](https://www.youtube.com/watch?v=5E0LU85EnTI)



응답중 대부분의 시간은 io 대기  cpu를 사용하는 시간은 극히 일부

대기하는동안 쓰레드르를 멈추고 있다면 손해

응답당 0.01%만 cpu를쓴다면 가상쓰레드를 10000개 만들면 된다!



커널 쓰레드는 2MB의 메모리 들고 생성하는데도 시간이 소모됨



비동기 코드는 단위테스트는 어렵고 분리도 어렵다 + 스택 트래스 어렵



가상쓰레드는 비용이 적은 JVM에서 관리하는 쓰레드 1000배 가볍다!
가볍기 때문에 풀링X

여전히 플랫폼쓰레드위에서 작동





가상 스레드를 실행시키기 위해 수정된 포크 조인 풀인 플랫폼 스레드풀 존재

가상스레드는 플래솜스레드에 마운트

실행

언마운트 (stack -> heap) io작업을 실행하고 있음을감지함 

CONTINATION.YIELD()가 차단 관련 작업<- JAVA.CONCURRNET도 포함

continue.rum() 호출하면 heap에서 가상스레드 메모리를 stack으로 가져와
포크 조인 풀에 마운트된 플랫폼 스레드의 대기 목록에 삭입





비용

쓰레드 컨텍스트 스위칭 + 가상쓰레드 컨텍스트 스위칭 < io 대기(스레드 대기)



주의 사항

- 병렬 스트림 처리X

- 네이티브코드 실행시 가상스레드가 플랫폼스레드에 고정된다(할당?)

- syncronized code  -> pinned
  
  - lock을 쓰자(read write lock)



3줄 요약

생산, 보유, 차단 비용이 저렴 -> 비동기 코드 의존X

동기화 블록은X

jVM에서 알아서 제거 해준다
