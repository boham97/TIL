#### 도커 도입시 장점

모든 언어의 어플리케이션을 하나의 물리적 서버에서 운영가능

**Cgroup**

control group의 약자, cpu시간, 시스템 메모리, 네트워크 대역폭등의 자원 관리

**Namespace**

시스템 리소스를 해당 프로세스에만 해당되는 자원 으로보이도록 하고 다른 프로세스와 격리 시키는 가상화 기능

UTS: 호스트네임 분할

IPC: 프로세스간 통신 격리

PID 실행 프로세스분할 관리

MNT 파일 시스템의 마운트 지점 분할 격리

NET 네트워크 리소스와 관련된 정보분할

USER user, group 분할

VM같은 물리적인 가상화 없이도 운영가능



#### 까먹지 말 명령어

`docker logs -f` `docker logs -tail 100` 로그, 마지막 100개 로그

`docker cp` 호스트 pc에 복사

`docker commit ~` 도커 컨테이너의 변경 사항을 새로운 도커 이미지로 저장

`docker ps -a` 정지된 컨테이너도 확인

#### 도커 이미지

도커 이미지는 각각의 이미지들을 서로 layer시키는 구조

베이스가 되는 이미지를 layer아래 read only로 마운트

컨테이너에서 쓰는 파일 시스템 부분을 read write로 마운트시킨다

ex)

```
스프링부트 이미지에서는
read only: openjdk:8-jdk-alpine
read write: jar파일 배치되는 부분
```



이미지 layer가 계층을 쌓을 수 있다는것을 기억하자

실행환경을 모두 고려X





#### 컨테이너와 통신 방법

`docker exec -it nginx ping -c 3 172.17.0.2` 특정 ip와 통신

`--link` 특정 컨테이너와 통신

bridge 네트워크 생성

`--network` 컨테이너 생성시 해당 브릿지 네트워크 사용

`--net=host` host 모드로 컨테이너 실행  `-p` 옵션 사용X

`--net=container` container모드 해당 컨테이너의 네트워크 구성을 참조하는 컨테이너와 동일하게 구성



#### 도커의 한계

인프라를 유연하게 조절할수 없다

- 도커 오케스트레이션
  
  여러 호스트를 단일 호스트처럼 사용할수 있다
  
  - 컨테이너의 프로비저닝 및 배포(프로비저닝:**IT 인프라를 생성하고 설정하는 프로세스**로서)
  
  - 컨테이너의 중복성 및 가용성
  
  - 컨테이너 인프라 확장 또는 제거 , 호스트 인프라 전체에 애플리케이션 로드 균등하게 분산
  
  - 다른 호스트로 컨테이너 이동
  
  - 컨테이너간의 리소스 할당
  
  - 네부 컨테이너에서 실행되는 서비스의 외부 노출
  
  - 컨테이너 간 서비스 검색 로드 밸런싱
  
  - 애플리케이션 실행하는 컨테이너와 관련하여 애플리케이션 구성



# Kubernetes

# = k len(ubernete)  s

# k8s


